"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2302],{2528:(s,e,t)=>{t.r(e),t.d(e,{assets:()=>i,contentTitle:()=>c,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>p});var n=t(4848),r=t(8453);const o={},c="sse_utils.py",a={id:"src/sunholo/mcp/sse_utils",title:"sse_utils.py",description:"Source: src/sunholo/mcp/sseutils.py",source:"@site/docs/src/sunholo/mcp/sse_utils.md",sourceDirName:"src/sunholo/mcp",slug:"/src/sunholo/mcp/sse_utils",permalink:"/docs/src/sunholo/mcp/sse_utils",draft:!1,unlisted:!1,editUrl:"https://github.com/sunholo-data/sunholo-py/tree/main/docs/docs/src/sunholo/mcp/sse_utils.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"mcp_manager.py",permalink:"/docs/src/sunholo/mcp/mcp_manager"},next:{title:"vac_mcp_server_fastmcp.py",permalink:"/docs/src/sunholo/mcp/vac_mcp_server_fastmcp"}},i={},p=[{value:"Functions",id:"functions",level:2},{value:"extract_sse_data(text: str) -&gt; Optional[str]",id:"extract_sse_datatext-str---optionalstr",level:3},{value:"is_sse_response(text: str) -&gt; bool",id:"is_sse_responsetext-str---bool",level:3},{value:"parse_sse_response(text: str) -&gt; Dict[str, Any]",id:"parse_sse_responsetext-str---dictstr-any",level:3}];function l(s){const e={a:"a",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",...(0,r.R)(),...s.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.header,{children:(0,n.jsx)(e.h1,{id:"sse_utilspy",children:"sse_utils.py"})}),"\n",(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.em,{children:"Source"}),": ",(0,n.jsx)(e.a,{href:"https://github.com/sunholo-data/sunholo-py/blob/main/src/sunholo/mcp/sse_utils.py",children:"src/sunholo/mcp/sse_utils.py"})]}),"\n",(0,n.jsx)(e.h2,{id:"functions",children:"Functions"}),"\n",(0,n.jsx)(e.h3,{id:"extract_sse_datatext-str---optionalstr",children:"extract_sse_data(text: str) -> Optional[str]"}),"\n",(0,n.jsx)(e.p,{children:"Extract the data portion from an SSE response."}),"\n",(0,n.jsx)(e.p,{children:"Args:\ntext: SSE-formatted response text"}),"\n",(0,n.jsx)(e.p,{children:"Returns:\nThe extracted data string, or None if not found"}),"\n",(0,n.jsx)(e.h3,{id:"is_sse_responsetext-str---bool",children:"is_sse_response(text: str) -> bool"}),"\n",(0,n.jsx)(e.p,{children:"Check if a response is in SSE format."}),"\n",(0,n.jsx)(e.p,{children:"Args:\ntext: Response text to check"}),"\n",(0,n.jsx)(e.p,{children:"Returns:\nTrue if the response appears to be SSE format"}),"\n",(0,n.jsx)(e.h3,{id:"parse_sse_responsetext-str---dictstr-any",children:"parse_sse_response(text: str) -> Dict[str, Any]"}),"\n",(0,n.jsx)(e.p,{children:"Parse SSE-formatted response from MCP server."}),"\n",(0,n.jsx)(e.p,{children:"FastMCP returns responses in SSE format when using HTTP transport,\neven with stateless_http=True. This function extracts the JSON data\nfrom the SSE format."}),"\n",(0,n.jsx)(e.p,{children:"Args:\ntext: Raw response text from MCP server"}),"\n",(0,n.jsx)(e.p,{children:"Returns:\nParsed JSON data from the SSE response"}),"\n",(0,n.jsx)(e.p,{children:"Raises:\nValueError: If the response cannot be parsed"}),"\n",(0,n.jsx)(e.p,{children:'Example:\n>>> response_text = \'event: message\\ndata: {"jsonrpc": "2.0", "id": 1, "result": {...}}\'\n>>> data = parse_sse_response(response_text)\n>>> print(data[\'result\'])'})]})}function d(s={}){const{wrapper:e}={...(0,r.R)(),...s.components};return e?(0,n.jsx)(e,{...s,children:(0,n.jsx)(l,{...s})}):l(s)}},8453:(s,e,t)=>{t.d(e,{R:()=>c,x:()=>a});var n=t(6540);const r={},o=n.createContext(r);function c(s){const e=n.useContext(o);return n.useMemo((function(){return"function"==typeof s?s(e):{...e,...s}}),[e,s])}function a(s){let e;return e=s.disableParentContext?"function"==typeof s.components?s.components(r):s.components||r:c(s.components),n.createElement(o.Provider,{value:e},s.children)}}}]);