"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[444],{8743:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>a});var s=t(4848),r=t(8453);const i={},l="content_buffer.py",o={id:"src/sunholo/streaming/content_buffer",title:"content_buffer.py",description:"Source: src/sunholo/streaming/contentbuffer.py",source:"@site/docs/src/sunholo/streaming/content_buffer.md",sourceDirName:"src/sunholo/streaming",slug:"/src/sunholo/streaming/content_buffer",permalink:"/docs/src/sunholo/streaming/content_buffer",draft:!1,unlisted:!1,editUrl:"https://github.com/sunholo-data/sunholo-py/tree/main/docs/docs/src/sunholo/streaming/content_buffer.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"streaming.py",permalink:"/docs/src/sunholo/streaming/"},next:{title:"langserve.py",permalink:"/docs/src/sunholo/streaming/langserve"}},c={},a=[{value:"Classes",id:"classes",level:2},{value:"BufferStreamingStdOutCallbackHandler",id:"bufferstreamingstdoutcallbackhandler",level:3},{value:"BufferStreamingStdOutCallbackHandlerAsync",id:"bufferstreamingstdoutcallbackhandlerasync",level:3},{value:"ContentBuffer",id:"contentbuffer",level:3}];function h(e){const n={a:"a",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"content_bufferpy",children:"content_buffer.py"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Source"}),": ",(0,s.jsx)(n.a,{href:"https://github.com/sunholo-data/sunholo-py/blob/main/src/sunholo/streaming/content_buffer.py",children:"src/sunholo/streaming/content_buffer.py"})]}),"\n",(0,s.jsx)(n.h2,{id:"classes",children:"Classes"}),"\n",(0,s.jsx)(n.h3,{id:"bufferstreamingstdoutcallbackhandler",children:"BufferStreamingStdOutCallbackHandler"}),"\n",(0,s.jsx)(n.p,{children:"A callback handler for streaming LLM output to a content buffer."}),"\n",(0,s.jsx)(n.p,{children:"This class handles the streaming of output from a large language model (LLM),\nprocesses tokens from the model output, and writes them to a ContentBuffer.\nIt supports handling different types of tokens and keeps track of code blocks\nand questions."}),"\n",(0,s.jsx)(n.p,{children:"Attributes:\ncontent_buffer (ContentBuffer): The buffer to which content is streamed.\ntokens (str): Tokens that indicate the end of a statement, for buffer flushing.\nbuffer (str): Temporary storage for accumulating streamed tokens.\nstream_finished (threading.Event): Signals when the streaming is finished.\nin_code_block (bool): Indicates whether the current context is a code block.\nin_question_block (bool): Indicates whether the current context is a question block.\nquestion_buffer (str): Stores the accumulated questions."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"init"}),"(self, content_buffer: sunholo.streaming.content_buffer.ContentBuffer, tokens: str = '.?!\\n', *args, **kwargs)"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Initializes a new BufferStreamingStdOutCallbackHandler instance."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'Args:\ncontent_buffer (ContentBuffer): The buffer to which content will be written.\ntokens (str): Tokens that indicate the end of a statement (default: ".?!\n").\n*args: Additional positional arguments.\n**kwargs: Additional keyword arguments.'}),"\n",(0,s.jsx)(n.p,{children:"Sets up the callback handler with the given content buffer and tokens.\nInitializes tracking variables for code blocks, buffer content, and the finished signal."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"_is_heartbeat_token(self, token: str) -> bool"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Detects if the token is a heartbeat message."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"_process_buffer(self)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Processes the buffer content and writes to the content buffer."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If the buffer ends with a numbered list pattern or specified tokens, the buffer is flushed\nto the content buffer. Otherwise, the buffer is left intact for further accumulation."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"_strip_heartbeat_markers(self, token: str) -> str"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Removes the [[HEARTBEAT]] markers from the token."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"on_llm_end(self, response, **kwargs: Any) -> None"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Handles the end of LLM streaming."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Args:\nresponse: The result returned by the LLM.\n**kwargs: Additional keyword arguments."}),"\n",(0,s.jsx)(n.p,{children:"Writes any remaining buffer content to the content buffer, and sets a signal indicating\nthat the streaming has finished."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["on_llm_new_token(self, token: str, **kwargs: Any) -> None","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Processes a new token from the LLM output."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Args:\ntoken (str): The new token generated by the LLM.\n**kwargs: Additional keyword arguments."}),"\n",(0,s.jsx)(n.p,{children:"Accumulates the token in the buffer and processes it based on the current context.\nThe buffer content is written to the content buffer when appropriate tokens or\npatterns are detected."}),"\n",(0,s.jsx)(n.h3,{id:"bufferstreamingstdoutcallbackhandlerasync",children:"BufferStreamingStdOutCallbackHandlerAsync"}),"\n",(0,s.jsx)(n.p,{children:"An async callback handler for streaming LLM output to a content buffer."}),"\n",(0,s.jsx)(n.p,{children:"This class handles the streaming of output from a large language model (LLM),\nprocesses tokens from the model output, and writes them to a ContentBuffer.\nIt supports handling different types of tokens and keeps track of code blocks\nand questions."}),"\n",(0,s.jsx)(n.p,{children:"Attributes:\ncontent_buffer (ContentBuffer): The buffer to which content is streamed.\ntokens (str): Tokens that indicate the end of a statement, for buffer flushing.\nbuffer (str): Temporary storage for accumulating streamed tokens.\nstream_finished (asyncio.Event): Signals when the streaming is finished.\nin_code_block (bool): Indicates whether the current context is a code block."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"init"}),"(self, content_buffer: sunholo.streaming.content_buffer.ContentBuffer, tokens: str = '.?!\\n', *args, **kwargs)"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Initializes a new BufferStreamingStdOutCallbackHandler instance."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'Args:\ncontent_buffer (ContentBuffer): The buffer to which content will be written.\ntokens (str): Tokens that indicate the end of a statement (default: ".?!\n").\n*args: Additional positional arguments.\n**kwargs: Additional keyword arguments.'}),"\n",(0,s.jsx)(n.p,{children:"Sets up the callback handler with the given content buffer and tokens.\nInitializes tracking variables for code blocks, buffer content, and the finished signal."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"_async_process_buffer(self)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Asynchronously processes the buffer content and writes to the content buffer."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If the buffer ends with a numbered list pattern or specified tokens, the buffer is flushed\nto the content buffer. Otherwise, the buffer is left intact for further accumulation."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"_is_heartbeat_token(self, token: str) -> bool"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Detects if the token is a heartbeat message."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"_strip_heartbeat_markers(self, token: str) -> str"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Removes the [[HEARTBEAT]] markers from the token."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"async_on_llm_end(self, response, **kwargs: Any) -> None"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Asynchronously handles the end of LLM streaming."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Args:\nresponse: The result returned by the LLM.\n**kwargs: Additional keyword arguments."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["async_on_llm_new_token(self, token: str, **kwargs: Any) -> None","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"contentbuffer",children:"ContentBuffer"}),"\n",(0,s.jsx)(n.p,{children:"A buffer class for storing and managing textual content."}),"\n",(0,s.jsx)(n.p,{children:"This class provides methods to write text to the buffer, read the entire buffer content,\nand clear the buffer content. The buffer can be used to collect text output for further\nprocessing or inspection."}),"\n",(0,s.jsx)(n.p,{children:"Attributes:\ncontent (str): Stores the textual content of the buffer."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"init"}),"(self)","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Initializes a new ContentBuffer instance."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The content buffer starts with an empty string, and logging is initialized to indicate\nthat the buffer has been created."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["async_clear(self)","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Asynchronously clears the content buffer."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Empties the buffer content, resetting it to an empty string."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["async_read(self) -> str","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Asynchronously reads the entire content from the buffer."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Returns:\nstr: The content of the buffer."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["async_write(self, text: str)","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Asynchronously writes text to the content buffer."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Args:\ntext (str): The text to be added to the buffer."}),"\n",(0,s.jsx)(n.p,{children:"Adds the given text to the existing content of the buffer."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["clear(self)","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Clears the content buffer."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Empties the buffer content, resetting it to an empty string."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["read(self) -> str","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reads the entire content from the buffer."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Returns:\nstr: The content of the buffer."}),"\n",(0,s.jsx)(n.p,{children:"Provides the entire content stored in the buffer."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["write(self, text: str)","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Writes text to the content buffer."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Args:\ntext (str): The text to be added to the buffer."}),"\n",(0,s.jsx)(n.p,{children:"Adds the given text to the existing content of the buffer."})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var s=t(6540);const r={},i=s.createContext(r);function l(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);