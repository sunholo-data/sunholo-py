"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7622],{459:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>a,metadata:()=>o,toc:()=>h});var s=t(4848),r=t(8453);const a={},i="langserve.py",o={id:"sunholo/agents/langserve",title:"langserve.py",description:"Source: sunholo/agents/langserve.py",source:"@site/docs/sunholo/agents/langserve.md",sourceDirName:"sunholo/agents",slug:"/sunholo/agents/langserve",permalink:"/docs/sunholo/agents/langserve",draft:!1,unlisted:!1,editUrl:"https://github.com/sunholo-data/sunholo-py/tree/main/docs/docs/sunholo/agents/langserve.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"vac_routes.py",permalink:"/docs/sunholo/agents/flask/vac_routes"},next:{title:"pubsub.py",permalink:"/docs/sunholo/agents/pubsub"}},c={},h=[{value:"Functions",id:"functions",level:2},{value:"prepare_request_data(user_input, endpoint, vector_name, **kwargs)",id:"prepare_request_datauser_input-endpoint-vector_name-kwargs",level:3},{value:"fetch_input_schema(endpoint, vector_name)",id:"fetch_input_schemaendpoint-vector_name",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"langservepy",children:"langserve.py"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Source"}),": ",(0,s.jsx)(n.a,{href:"https://github.com/sunholo-data/sunholo-py/blob/main/sunholo/agents/langserve.py",children:"sunholo/agents/langserve.py"})]}),"\n",(0,s.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,s.jsx)(n.h3,{id:"prepare_request_datauser_input-endpoint-vector_name-kwargs",children:"prepare_request_data(user_input, endpoint, vector_name, **kwargs)"}),"\n",(0,s.jsx)(n.p,{children:"Prepare the request data for an API call to a Langserve endpoint based on the input schema from the specified endpoint.\nThe function constructs a request payload incorporating user input, endpoint-specific configurations,\nand additional parameters passed through keyword arguments (kwargs)."}),"\n",(0,s.jsx)(n.p,{children:"Parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"user_input (str): The main user input data to be processed."}),"\n",(0,s.jsx)(n.li,{children:"endpoint (str): The endpoint URL or identifier used to fetch the corresponding input schema."}),"\n",(0,s.jsx)(n.li,{children:"vector_name (str): The name of the vector, indicating the specific processing or analysis vector to be used."}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"**kwargs"}),": Arbitrary keyword arguments. Special handling for 'configurable' which, if present,\nis moved to a separate 'config' dictionary in the output payload."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The function extracts the input schema based on the provided endpoint and vector name, logs this schema,\nand constructs the payload under the 'input' key based on this schema. If 'configurable' is present in kwargs,\nit is placed in a separate 'config' dictionary within the payload, allowing configuration settings to be\nspecified separately from the input data."}),"\n",(0,s.jsxs)(n.p,{children:["Returns:\ndict: A dictionary structured as ",(0,s.jsx)(n.code,{children:'{ "input": {...}, "config": {...} }'})," if 'configurable' is provided; otherwise, the 'config' key is omitted."]}),"\n",(0,s.jsx)(n.p,{children:"If the input schema is not found or invalid, an error is logged and None is returned."}),"\n",(0,s.jsx)(n.h3,{id:"fetch_input_schemaendpoint-vector_name",children:"fetch_input_schema(endpoint, vector_name)"}),"\n",(0,s.jsx)(n.p,{children:"Fetch the input schema from the Langserve endpoint and vector name, including a caching mechanism\nto avoid redundant network calls. If the schema for a given endpoint is already cached, it retrieves\nit directly from the cache; otherwise, it makes an HTTP GET request to fetch the schema."}),"\n",(0,s.jsx)(n.p,{children:"Parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"endpoint (str): The URL of the endpoint from which the schema needs to be fetched."}),"\n",(0,s.jsx)(n.li,{children:"vector_name (str): The name of the vector that might modify the headers sent with the request."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Returns:\ndict or None: Returns the fetched schema as a dictionary if the request is successful and the schema is valid. Returns None if there is an error fetching the schema."}),"\n",(0,s.jsx)(n.p,{children:"This function also logs the fetching process, providing information about the fetched schema or any errors encountered."}),"\n",(0,s.jsx)(n.p,{children:"Examples"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'endpoint = "http://api.example.com/schema/weather"\nvector_name = "weatherQuery"\nschema = fetch_input_schema(endpoint, vector_name)\nif schema:\n    print("Schema fetched successfully:", schema)\nelse:\n    print("Failed to fetch schema")\n\ncached_schema = fetch_input_schema(endpoint, vector_name)\nprint("Cached Schema:", cached_schema)\n'})})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);