"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8206],{517:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var t=s(4848),r=s(8453);const i={},o="discovery_engine_client.py",c={id:"src/sunholo/discovery_engine/discovery_engine_client",title:"discovery_engine_client.py",description:"Source: src/sunholo/discoveryengine/discoveryengineclient.py",source:"@site/docs/src/sunholo/discovery_engine/discovery_engine_client.md",sourceDirName:"src/sunholo/discovery_engine",slug:"/src/sunholo/discovery_engine/discovery_engine_client",permalink:"/docs/src/sunholo/discovery_engine/discovery_engine_client",draft:!1,unlisted:!1,editUrl:"https://github.com/sunholo-data/sunholo-py/tree/main/docs/docs/src/sunholo/discovery_engine/discovery_engine_client.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"create_new.py",permalink:"/docs/src/sunholo/discovery_engine/create_new"},next:{title:"get_ai_search_chunks.py",permalink:"/docs/src/sunholo/discovery_engine/get_ai_search_chunks"}},a={},l=[{value:"Classes",id:"classes",level:2},{value:"DiscoveryEngineClient",id:"discoveryengineclient",level:3}];function u(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"discovery_engine_clientpy",children:"discovery_engine_client.py"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Source"}),": ",(0,t.jsx)(n.a,{href:"https://github.com/sunholo-data/sunholo-py/blob/main/src/sunholo/discovery_engine/discovery_engine_client.py",children:"src/sunholo/discovery_engine/discovery_engine_client.py"})]}),"\n",(0,t.jsx)(n.h2,{id:"classes",children:"Classes"}),"\n",(0,t.jsx)(n.h3,{id:"discoveryengineclient",children:"DiscoveryEngineClient"}),"\n",(0,t.jsx)(n.p,{children:"Client for interacting with Google Cloud Discovery Engine."}),"\n",(0,t.jsx)(n.p,{children:"Args:\nproject_id (str): Your Google Cloud project ID.\ndata_store_id (str): The ID of your Discovery Engine data store.\nlocation (str, optional): The location of the data store (default is 'eu')."}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'client = DiscoveryEngineClient(project_id=\'your-project-id\', data_store_id=\'your-data-store-id\')\n\n# Create a collection\ncollection_name = client.create_collection("my_new_collection")\n\n# Perform a search\nsearch_response = client.get_chunks("your query", "your_collection_id")\n\n'})}),"\n",(0,t.jsx)(n.p,{children:"Parsing:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Perform a search\nsearch_response = client.get_chunks("your query", "your_collection_id")\n\n# Iterate through the search results\nfor result in search_response.results:\n    # Get the document (which contains the chunks)\n    document = result.document\n\n    # Iterate through the chunks within the document\n    for chunk in document.chunks:\n        chunk_text = chunk.snippet  # Extract the text content of the chunk\n        chunk_document_name = chunk.document_name  # Get the name of the document the chunk belongs to\n        \n        # Do something with the chunk_text and chunk_document_name (e.g., print, store, etc.)\n        print(f"Chunk Text: &#123;chunk_text&#125;")\n        print(f"Document Name: &#123;chunk_document_name&#125;")\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"init"}),"(self, data_store_id=None, engine_id=None, project_id=None, location='eu')"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Initialize self.  See help(type(self)) for accurate signature."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"_create_unique_gsuri_docid(self, gcs_uri: str)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"_import_document_request(self, request) -> str"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Handles the common logic for making an ImportDocumentsRequest, including retrying."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Args:\nrequest (discoveryengine.ImportDocumentsRequest): The prepared request object."}),"\n",(0,t.jsx)(n.p,{children:"Returns:\nstr: The operation name."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"_search_data_store_path(self, data_store_id: str, collection_id: str = 'default_collection', serving_config: str = 'default_serving_config')"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"async_get_chunks(self, query: str, num_previous_chunks: int = 3, num_next_chunks: int = 3, page_size: int = 10, parse_chunks_to_string: bool = True, serving_config: str = 'default_serving_config', data_store_ids: Optional[List[str]] = None, filter_str: str = None)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Asynchronously retrieves chunks or documents based on a query."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Args:\nquery (str): The search query.\nnum_previous_chunks (int, optional): Number of previous chunks to return for context (default is 3).\nnum_next_chunks (int, optional): Number of next chunks to return for context (default is 3).\npage_size (int, optional): The maximum number of results to return per page (default is 10).\nparse_chunks_to_string: If True will put chunks in one big string, False will return object\nserving_config: The resource name of the Search serving config\ndata_store_ids: If you want to search over many data stores, not just the one that was used to init the class.\nThey should be of the format projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}"}),"\n",(0,t.jsx)(n.p,{children:"Returns:\ndiscoveryengine.SearchResponse or str: The search response object or string of chunks."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["async_get_documents(self, query: str, page_size: int = 10, parse_documents_to_string: bool = True, serving_config: str = 'default_serving_config', data_store_ids: Optional[List[str]] = None, filter_str: str = None, max_limit: int = None)","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Asynchronously retrieves entire documents based on a query."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Args:\nquery (str): The search query.\npage_size (int, optional): The maximum number of results to return per page (default is 10).\nparse_documents_to_string: If True will put documents in one big string, False will return object\nserving_config: The resource name of the Search serving config\ndata_store_ids: If you want to search over many data stores, not just the one that was used to init the class.\nThey should be of the format projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}"}),"\n",(0,t.jsx)(n.p,{children:"Returns:\ndiscoveryengine.SearchResponse or str: The search response object or string of documents."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"async_process_chunks(self, response)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"async_process_documents(self, response, max_limit: int = None)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Process a search response containing documents into a formatted string asynchronously."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"async_search_by_objectId_and_or_date(self, query, objectId=None, date=None, **kwargs)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Searches and filters by objectId (exact match) and/or date asynchronously."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Args:\nquery (str): The search query.\nobjectId (str, optional): The exact objectId to filter by.\ndate (str, optional): The literal_iso_8601_datetime_format date to filter by e.g. 2025-02-24T12:25:30.123Z\n**kwargs: Additional keyword arguments to pass to `async_search_with_filters`."}),"\n",(0,t.jsx)(n.p,{children:"Returns:\nlist: A list of search results."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["async_search_engine(self, search_query: str, engine_id: str = None, serving_config_id: str = 'default_config', page_size: int = 10, return_snippet: bool = True, summary_result_count: int = 5, include_citations: bool = True, custom_prompt: Optional[str] = None, model_version: str = 'stable', query_expansion_level: 'discoveryengine.SearchRequest.QueryExpansionSpec.Condition' = <Condition.AUTO: 2>, spell_correction_mode: 'discoveryengine.SearchRequest.SpellCorrectionSpec.Mode' = <Mode.AUTO: 2>, filter_str: Optional[str] = None, boost_spec: Optional[ForwardRef('discoveryengine.SearchRequest.BoostSpec')] = None, params: Optional[Dict[str, Any]] = None, user_pseudo_id: Optional[str] = None, collection_id: str = 'default_collection')","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Performs an asynchronous search against a specified Discovery Engine Search Engine."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Allows configuration for snippets, summaries, query expansion, spell correction, etc."}),"\n",(0,t.jsx)(n.p,{children:"Args:\n(Same arguments as the synchronous search_engine method)"}),"\n",(0,t.jsx)(n.p,{children:"Returns:\nAn SearchAsyncPager object to iterate through results asynchronously,\nor None if an error occurs or the async client is not available."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["async_search_with_filters(self, query, filter_str=None, num_previous_chunks=3, num_next_chunks=3, page_size=10, parse_chunks_to_string=True, serving_config='default_serving_config', data_store_ids: Optional[List[str]] = None, content_search_spec_type='chunks', max_limit=None)","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Searches with a generic filter string asynchronously."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Args:\nquery (str): The search query.\nfilter_str (str, optional): The filter string to apply (e.g., \"source LIKE 'my_source' AND eventTime > TIMESTAMP('2024-01-01')\").\n#... other parameters from get_chunks"}),"\n",(0,t.jsx)(n.p,{children:"Returns:\ndiscoveryengine.SearchResponse or str: The search response object or string of chunks."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"chunk_format(self, chunk)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"create_data_store(self, type='chunk', chunk_size: int = 500, collection: str = 'default_collection')"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"create_data_store_chunk(self, chunk_size: int = 500, collection: str = 'default_collection') -> str"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Creates a new data store with default configuration."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Args:\nchunk_size (int, optional): The size of the chunks to create for documents (default is 500)."}),"\n",(0,t.jsx)(n.p,{children:"Returns:\nstr: The name of the long-running operation for data store creation."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"create_engine(self, engine_id: str, data_store_ids: List[str], solution_type=None, search_tier=None, search_add_ons=None) -> str"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You only need this if calling Data Store via Vertex Tools."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"data_store_path(self, collection: str = 'default_collection')"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"document_format(self, document)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Format a document for string output."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"get_chunks(self, query: str, num_previous_chunks: int = 3, num_next_chunks: int = 3, page_size: int = 10, parse_chunks_to_string: bool = True, serving_config: str = 'default_serving_config', data_store_ids: Optional[List[str]] = None, filter_str: str = None)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Retrieves chunks or documents based on a query."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Args:\nquery (str): The search query.\nnum_previous_chunks (int, optional): Number of previous chunks to return for context (default is 3).\nnum_next_chunks (int, optional): Number of next chunks to return for context (default is 3).\npage_size (int, optional): The maximum number of results to return per page (default is 10).\nparse_chunks_to_string: If True will put chunks in one big string, False will return object\nserving_config: The resource name of the Search serving config\ndata_store_ids: If you want to search over many data stores, not just the one that was used to init the class.\nThey should be of the format projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}"}),"\n",(0,t.jsx)(n.p,{children:"Returns:\ndiscoveryengine.SearchResponse or str: The search response object or string of chunks."}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"search_response = client.get_chunks('your query', 'your_collection_id')\nfor result in search_response.results:\n    for chunk in result.document.chunks:\n        print(f\"Chunk: &#123;chunk.snippet&#125;, document name: &#123;chunk.document_name&#125;\")\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["get_documents(self, query: str, page_size: int = 10, parse_documents_to_string: bool = True, serving_config: str = 'default_serving_config', data_store_ids: Optional[List[str]] = None, filter_str: str = None, max_limit: int = None)","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Retrieves entire documents based on a query."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Args:\nquery (str): The search query.\npage_size (int, optional): The maximum number of results to return per page (default is 10).\nparse_documents_to_string: If True will put documents in one big string, False will return object\nserving_config: The resource name of the Search serving config\ndata_store_ids: If you want to search over many data stores, not just the one that was used to init the class.\nThey should be of the format projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}"}),"\n",(0,t.jsx)(n.p,{children:"Returns:\ndiscoveryengine.SearchResponse or str: The search response object or string of documents."}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"search_response = client.get_documents('your query')\nfor result in search_response.results:\n    doc = result.document\n    print(f\"Document: &#123;doc.name&#125;, Title: &#123;doc.derived_struct_data.get('title')&#125;\")\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"get_mime_type(self, uri: str)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"import_document_with_metadata(self, gcs_uri: str, metadata: dict, branch='default_branch')"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Imports a single document with metadata."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Args:\ngcs_uri: The GCS URI of the document to import.\nmetadata: A dictionary containing the metadata for the document.\nbranch: The branch to import the document into."}),"\n",(0,t.jsx)(n.p,{children:"Returns:\nstr: The operation name."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["import_documents(self, gcs_uri: Optional[str] = None, data_schema='content', branch='default_branch', bigquery_dataset: Optional[str] = None, bigquery_table: Optional[str] = None, bigquery_project_id: Optional[str] = None) -> str","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Args:"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"gcs_uri: Required. List of Cloud Storage URIs to input files. Each URI can be up to 2000 characters long. URIs can match the full object path (for example, gs://bucket/directory/object.json) or a pattern matching one or more files, such as gs://bucket/directory/*.json. A request can contain at most 100 files (or 100,000 files if data_schema is content). Each file can be up to 2 GB (or 100 MB if data_schema is content)."}),"\n",(0,t.jsx)(n.li,{children:"data_schema: Must be one of 'user_event', 'custom' or 'document' if using BigQuery. Default 'content' only for GCS. The schema to use when parsing the data from the source. Supported values for document imports: - document (default): One JSON Document per line. Each document must have a valid Document.id. - content: Unstructured data (e.g. PDF, HTML). Each file matched by input_uris becomes a document, with the ID set to the first 128 bits of SHA256(URI) encoded as a hex string. - custom: One custom data JSON per row in arbitrary format that conforms to the defined Schema of the data store. This can only be used by the GENERIC Data Store vertical. - csv: A CSV file with header conforming to the defined Schema of the data store. Each entry after the header is imported as a Document. This can only be used by the GENERIC Data Store vertical. Supported values for user event imports: - user_event (default): One JSON UserEvent per line."}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"import_documents_with_metadata(self, gcs_uri: str, data_schema='content', branch='default_branch')"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Supply a JSONLD GCS location to import all the GS URIs within and their metadata"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"process_chunks(self, response)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"process_documents(self, response, max_limit: int = None)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Process a search response containing documents into a formatted string."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"search_by_objectId_and_or_date(self, query, objectId=None, date=None, **kwargs)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Searches and filters by objectId (exact match) and/or date."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Args:\nquery (str): The search query.\nobjectId (str, optional): The exact objectId to filter by.\ndate (str, optional): The literal_iso_8601_datetime_format date to filter by e.g. 2025-02-24T12:25:30.123Z\n**kwargs: Additional keyword arguments to pass to `search_with_filters`."}),"\n",(0,t.jsx)(n.p,{children:"Returns:\nlist: A list of search results."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"search_engine(self, search_query: str, engine_id: str = None, serving_config_id: str = 'default_config', page_size: int = 10, return_snippet: bool = True, summary_result_count: int = 5, include_citations: bool = True, custom_prompt: Optional[str] = None, model_version: str = 'stable', query_expansion_level: 'discoveryengine.SearchRequest.QueryExpansionSpec.Condition' = <Condition.AUTO: 2>, spell_correction_mode: 'discoveryengine.SearchRequest.SpellCorrectionSpec.Mode' = <Mode.AUTO: 2>, filter_str: Optional[str] = None, boost_spec: Optional[ForwardRef('discoveryengine.SearchRequest.BoostSpec')] = None, params: Optional[Dict[str, Any]] = None, user_pseudo_id: Optional[str] = None, collection_id: str = 'default_collection')"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Performs a search against a specified Discovery Engine Search Engine."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Allows configuration for snippets, summaries, query expansion, spell correction, etc."}),"\n",(0,t.jsx)(n.p,{children:'Args:\nsearch_query: The user\'s search query string.\nengine_id: The ID of the search engine to query or uses class engine_id it init with.\nserving_config_id: The ID of the specific serving config for the engine.\npage_size: Maximum number of results per page.\nreturn_snippet: Whether to request snippets in the results.\nsummary_result_count: Number of results to use for generating a summary.\nSet to 0 to disable summaries.\ninclude_citations: Whether summaries should include citations.\ncustom_prompt: A custom preamble text to guide the summary generation model.\nmodel_version: The version of the summary generation model (e.g., "stable").\nquery_expansion_level: Level of query expansion to apply (AUTO, DISABLED).\nspell_correction_mode: Mode for spell correction (AUTO, SUGGEST).\nfilter_str: An optional filter string to apply to the search.\nboost_spec: Optional boost specification object.\nparams: Optional dictionary of custom parameters.\nuser_pseudo_id: Optional unique identifier for the user/session.\ncustom_fine_tuning_spec: Optional spec to use a fine-tuned model.\ncollection_id: The collection ID associated with the engine.'}),"\n",(0,t.jsx)(n.p,{children:"Returns:\nA SearchPager object to iterate through results, or None if an error occurs."}),"\n",(0,t.jsx)(n.p,{children:"Example:\nclient = DiscoveryEngineClient(\nproject_id=PROJECT_ID,\ndata_store_id=DATA_STORE_ID,\nlocation=LOCATION\n)"}),"\n",(0,t.jsx)(n.h1,{id:"----example-searching-an-engine----",children:"--- Example: Searching an Engine ---"}),"\n",(0,t.jsx)(n.p,{children:'search_query_engine = "tell me about search engines"\nlog.info(f"\n--- Searching Engine: {ENGINE_ID} ---")\nengine_pager = client.search_engine(\nsearch_query=search_query_engine,\nengine_id=ENGINE_ID,\nsummary_result_count=3 # Request a summary for 3 results\n)'}),"\n",(0,t.jsx)(n.p,{children:"if engine_pager:\nresults_found = False"}),"\n",(0,t.jsx)(n.h1,{id:"iterate-through-pages-to-get-summaryresults",children:"Iterate through pages to get summary/results"}),"\n",(0,t.jsx)(n.p,{children:'for page in engine_pager.pages:\nresults_found = True\nif page.summary:\nprint(f"\nSearch Summary:\n{page.summary.summary_text}\n")'}),"\n",(0,t.jsx)(n.h1,{id:"citations-are-part-of-the-summary-object-if-requested",children:"Citations are part of the summary object if requested"}),"\n",(0,t.jsx)(n.p,{children:'if page.summary.summary_with_metadata:\nprint("Summary Metadata/Citations:")\nfor citation in page.summary.summary_with_metadata.citations:\nprint(f"  - Citation Source: {citation.sources}")'}),"\n",(0,t.jsx)(n.h1,{id:"access-references-etc-if-needed",children:"Access references etc. if needed"}),"\n",(0,t.jsx)(n.p,{children:'print("Results on this page:")\nfor result in page.results:\nprint(f"  ID: {result.document.id}")\nprint(f"  Name: {result.document.name}")'}),"\n",(0,t.jsx)(n.h1,{id:"access-snippet-if-available-in-resultdocumentderived_struct_datasnippets",children:"Access snippet if available in result.document.derived_struct_data['snippets']"}),"\n",(0,t.jsx)(n.h1,{id:"access-other-document-fields-as-needed-struct_data-etc",children:"Access other document fields as needed (struct_data, etc.)"}),"\n",(0,t.jsx)(n.h1,{id:"printf--raw-result-result--for-detailed-inspection",children:'print(f"  Raw Result: {result}") # For detailed inspection'}),"\n",(0,t.jsx)(n.p,{children:'print("-" * 10)'}),"\n",(0,t.jsx)(n.p,{children:'if not results_found:\nprint("No results found for the engine search.")\nelse:\nprint(f"Engine search failed for query: \'{search_query_engine}\'")'}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"search_with_filters(self, query, filter_str=None, num_previous_chunks=3, num_next_chunks=3, page_size=10, parse_chunks_to_string=True, serving_config='default_serving_config', data_store_ids: Optional[List[str]] = None, content_search_spec_type='chunks', max_limit=None)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Searches with a generic filter string."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Args:\nquery (str): The search query.\nfilter_str (str, optional): The filter string to apply (e.g., \"source LIKE 'my_source' AND eventTime > TIMESTAMP('2024-01-01')\").\n#... other parameters from get_chunks"}),"\n",(0,t.jsx)(n.p,{children:"Returns:\ndiscoveryengine.SearchResponse or str: The search response object or string of chunks."})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>c});var t=s(6540);const r={},i=t.createContext(r);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);