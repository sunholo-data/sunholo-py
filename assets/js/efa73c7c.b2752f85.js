"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[206],{4443:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>a});var i=s(4848),l=s(8453);const t={},o="genaiv2.py",r={id:"src/sunholo/genai/genaiv2",title:"genaiv2.py",description:"Source: src/sunholo/genai/genaiv2.py",source:"@site/docs/src/sunholo/genai/genaiv2.md",sourceDirName:"src/sunholo/genai",slug:"/src/sunholo/genai/genaiv2",permalink:"/docs/src/sunholo/genai/genaiv2",draft:!1,unlisted:!1,editUrl:"https://github.com/sunholo-data/sunholo-py/tree/main/docs/docs/src/sunholo/genai/genaiv2.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"file_handling.py",permalink:"/docs/src/sunholo/genai/file_handling"},next:{title:"images.py",permalink:"/docs/src/sunholo/genai/images"}},d={},a=[{value:"Classes",id:"classes",level:2},{value:"GoogleAI",id:"googleai",level:3},{value:"GoogleAIConfig",id:"googleaiconfig",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"genaiv2py",children:"genaiv2.py"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Source"}),": ",(0,i.jsx)(n.a,{href:"https://github.com/sunholo-data/sunholo-py/blob/main/src/sunholo/genai/genaiv2.py",children:"src/sunholo/genai/genaiv2.py"})]}),"\n",(0,i.jsx)(n.h2,{id:"classes",children:"Classes"}),"\n",(0,i.jsx)(n.h3,{id:"googleai",children:"GoogleAI"}),"\n",(0,i.jsxs)(n.p,{children:["A wrapper class for Google's v2 Generative AI APIs.\nSee ",(0,i.jsx)(n.a,{href:"https://ai.google.dev/gemini-api/docs/models/gemini-v2",children:"https://ai.google.dev/gemini-api/docs/models/gemini-v2"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"init"}),"(self, config: sunholo.genai.genaiv2.GoogleAIConfig)","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Initialize the GoogleAI client."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Args:\nconfig (GoogleAIConfig): Configuration for client initialization"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"_process_responses(self, session) -> List[str]"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Internal method to process session responses."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"_record_audio(self, duration: float = 5.0, sample_rate: int = 16000) -> bytes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Internal method to record audio."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"_record_video(self, duration: float = 5.0) -> List[bytes]"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Internal method to record video frames."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"count_tokens(self, text: str, model: Optional[str] = None) -> int"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Count the number of tokens in the text."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Args:\ntext (str): Input text\nmodel (Optional[str]): Model to use for tokenization"}),"\n",(0,i.jsx)(n.p,{children:"Returns:\nint: Number of tokens"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["generate_text(self, prompt: str, model: Optional[str] = None, temperature: float = 0.7, max_output_tokens: int = 1024, top_p: float = 0.95, top_k: int = 20, stop_sequences: Optional[List[str]] = None, system_prompt: Optional[str] = None, tools: Optional[List[ForwardRef('types.Tool')]] = None) -> str","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Generate text using the specified model."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Args:\nprompt (str): The input prompt\nmodel (Optional[str]): Model name to use\ntemperature (float): Controls randomness (0.0-1.0)\nmax_output_tokens (int): Maximum number of tokens to generate\ntop_p (float): Nucleus sampling parameter\ntop_k (int): Top-k sampling parameter\nstop_sequences (Optional[List[str]]): Sequences that stop generation\nsystem_prompt (Optional[str]): System-level instruction\ntools: list of python functions or Tool objects"}),"\n",(0,i.jsx)(n.p,{children:"Returns:\nstr: Generated text response"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"generate_text_async(self, prompt: str, model: Optional[str] = None, **kwargs) -> str"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Async version of generate_text."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"get_embedding(self, text: Union[str, List[str]], model: str = 'text-embedding-004', output_dim: Optional[int] = None) -> Union[List[float], List[List[float]]]"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Get text embeddings."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Args:\ntext (Union[str, List[str]]): Text to embed\nmodel (str): Embedding model to use\noutput_dim (Optional[int]): Desired embedding dimension"}),"\n",(0,i.jsx)(n.p,{children:"Returns:\nUnion[List[float], List[List[float]]]: Embeddings"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"google_search_tool(self) -> 'types.Tool'"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"gs_uri(self, uri, mime_type=None)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"live_async(self, prompt: Union[str, List[Union[str, bytes]], NoneType] = None, input_type: str = 'text', duration: Optional[float] = None, model: Optional[str] = None, **kwargs) -> str"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Live Multimodal API with support for text, audio, and video inputs."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:'Args:\ninput_type: Type of input ("text", "audio", or "video")\nprompt: Text prompt or list of text/binary chunks\nduration: Recording duration for audio/video in seconds\nmodel: Optional model name\n**kwargs: Additional configuration parameters'}),"\n",(0,i.jsx)(n.p,{children:"Returns:\nstr: Generated response text"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"local_file(self, filename, mime_type=None)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"stream_text(self, prompt: str, model: Optional[str] = None, **kwargs) -> 'Generator[str, None, None]'"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Stream text generation responses."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Args:\nprompt (str): The input prompt\nmodel (Optional[str]): Model name to use\n**kwargs: Additional configuration parameters"}),"\n",(0,i.jsx)(n.p,{children:"Yields:\nstr: Chunks of generated text"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["structured_output(self, prompt: str, schema: Union[pydantic.main.BaseModel, Dict, type, TypedDict], model: Optional[str] = None, is_list: bool = False) -> Dict","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Generate structured output according to a schema."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Args:\nprompt (str): Input prompt\nschema (Union[BaseModel, Dict, type]): Schema definition (Pydantic model, TypedDict, or raw schema)\nmodel (Optional[str]): Model to use\nis_list (bool): Whether to wrap the schema in a list"}),"\n",(0,i.jsx)(n.p,{children:"Returns:\nDict: Structured response matching schema"}),"\n",(0,i.jsx)(n.h3,{id:"googleaiconfig",children:"GoogleAIConfig"}),"\n",(0,i.jsxs)(n.p,{children:["Configuration class for GoogleAI client initialization.\nSee ",(0,i.jsx)(n.a,{href:"https://ai.google.dev/gemini-api/docs/models/gemini-v2",children:"https://ai.google.dev/gemini-api/docs/models/gemini-v2"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"copy"}),"(self) -> 'Self'"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Returns a shallow copy of the model."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"deepcopy"}),"(self, memo: 'dict[int, Any] | None' = None) -> 'Self'"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Returns a deep copy of the model."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"delattr"}),"(self, item: 'str') -> 'Any'"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement delattr(self, name)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"eq"}),"(self, other: 'Any') -> 'bool'"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Return self==value."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"getattr"}),"(self, item: 'str') -> 'Any'"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"getstate"}),"(self) -> 'dict[Any, Any]'"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Helper for pickle."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"init"}),"(self, /, **data: 'Any') -> 'None'"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Create a new model by parsing and validating input data from keyword arguments."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model."}),"\n",(0,i.jsx)(n.p,{children:"`self` is explicitly positional-only to allow `self` as a field name."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"iter"}),"(self) -> 'TupleGenerator'"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"So `dict(model)` works."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"pretty"}),"(self, fmt: 'typing.Callable[[Any], Any]', **kwargs: 'Any') -> 'typing.Generator[Any, None, None]'"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Used by devtools (",(0,i.jsx)(n.a,{href:"https://python-devtools.helpmanual.io/",children:"https://python-devtools.helpmanual.io/"}),") to pretty print objects."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"replace"}),"(self, **changes: 'Any') -> 'Self'"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"repr"}),"(self) -> 'str'"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Return repr(self)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"repr_args"}),"(self) -> '_repr.ReprArgs'"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"repr_name"}),"(self) -> 'str'"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Name of the instance's class, used in ",(0,i.jsx)(n.strong,{children:"repr"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"repr_recursion"}),"(self, object: 'Any') -> 'str'"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Returns the string representation of a recursive object."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"repr_str"}),"(self, join_str: 'str') -> 'str'"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"rich_repr"}),"(self) -> 'RichReprResult'"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Used by Rich (",(0,i.jsx)(n.a,{href:"https://rich.readthedocs.io/en/stable/pretty.html",children:"https://rich.readthedocs.io/en/stable/pretty.html"}),") to pretty print objects."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"setattr"}),"(self, name: 'str', value: 'Any') -> 'None'"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement setattr(self, name, value)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"setstate"}),"(self, state: 'dict[Any, Any]') -> 'None'"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"str"}),"(self) -> 'str'"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Return str(self)."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"_calculate_keys(self, *args: 'Any', **kwargs: 'Any') -> 'Any'"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"_copy_and_set_values(self, *args: 'Any', **kwargs: 'Any') -> 'Any'"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"_iter(self, *args: 'Any', **kwargs: 'Any') -> 'Any'"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"_setattr_handler(self, name: 'str', value: 'Any') -> 'Callable[[BaseModel, str, Any], None] | None'"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Get a handler for setting an attribute on the model instance."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Returns:\nA handler for setting an attribute on the model instance. Used for memoization of the handler.\nMemoizing the handlers leads to a dramatic performance improvement in `",(0,i.jsx)(n.strong,{children:"setattr"}),"`\nReturns `None` when memoization is not safe, then the attribute is set directly."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Returns a copy of the model."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:['!!! warning "Deprecated"\nThis method is now deprecated; use ',(0,i.jsx)(n.code,{children:"model_copy"})," instead."]}),"\n",(0,i.jsxs)(n.p,{children:["If you need ",(0,i.jsx)(n.code,{children:"include"})," or ",(0,i.jsx)(n.code,{children:"exclude"}),", use:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",metastring:'{test="skip" lint="skip"}',children:"data = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = &#123;**data, **(update or &#123;&#125;)&#125;\ncopied = self.model_validate(data)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Args:\ninclude: Optional set or mapping specifying which fields to include in the copied model.\nexclude: Optional set or mapping specifying which fields to exclude in the copied model.\nupdate: Optional dictionary of field-value pairs to override field values in the copied model.\ndeep: If True, the values of fields that are Pydantic models will be deep-copied."}),"\n",(0,i.jsx)(n.p,{children:"Returns:\nA copy of the model with included, excluded and updated fields as specified."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'!!! abstract "Usage Documentation"\n`model_copy`'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Returns a copy of the model."}),"\n",(0,i.jsxs)(n.p,{children:["!!! note\nThe underlying instance's [`",(0,i.jsx)(n.strong,{children:"dict"}),"`][object.",(0,i.jsx)(n.strong,{children:"dict"}),"] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property])."]}),"\n",(0,i.jsx)(n.p,{children:"Args:\nupdate: Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep: Set to `True` to make a deep copy of the model."}),"\n",(0,i.jsx)(n.p,{children:"Returns:\nNew model instance."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["model_dump(self, *, mode: \"Literal['json', 'python'] | str\" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'!!! abstract "Usage Documentation"\n`model_dump`'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude."}),"\n",(0,i.jsx)(n.p,{children:'Args:\nmode: The mode in which `to_python` should run.\nIf mode is \'json\', the output will only contain JSON serializable types.\nIf mode is \'python\', the output may contain non-JSON-serializable Python objects.\ninclude: A set of fields to include in the output.\nexclude: A set of fields to exclude from the output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to use the field\'s alias in the dictionary key if defined.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of `None`.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,\n"error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\nfallback: A function to call when an unknown value is encountered. If not provided,\na [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.'}),"\n",(0,i.jsx)(n.p,{children:"Returns:\nA dictionary representation of the model."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["model_dump_json(self, *, indent: 'int | None' = None, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, round_trip: 'bool' = False, warnings: \"bool | Literal['none', 'warn', 'error']\" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'!!! abstract "Usage Documentation"\n`model_dump_json`'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Generates a JSON representation of the model using Pydantic's `to_json` method."}),"\n",(0,i.jsx)(n.p,{children:'Args:\nindent: Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude: Field(s) to include in the JSON output.\nexclude: Field(s) to exclude from the JSON output.\ncontext: Additional context to pass to the serializer.\nby_alias: Whether to serialize using field aliases.\nexclude_unset: Whether to exclude fields that have not been explicitly set.\nexclude_defaults: Whether to exclude fields that are set to their default value.\nexclude_none: Whether to exclude fields that have a value of `None`.\nround_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings: How to handle serialization errors. False/"none" ignores them, True/"warn" logs errors,\n"error" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\nfallback: A function to call when an unknown value is encountered. If not provided,\na [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any: Whether to serialize fields with duck-typing serialization behavior.'}),"\n",(0,i.jsx)(n.p,{children:"Returns:\nA JSON string representation of the model."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["model_post_init(self, context: 'Any', /) -> 'None'","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Override this method to perform additional initialization after `",(0,i.jsx)(n.strong,{children:"init"}),"` and `model_construct`.\nThis is useful if you want to do some validation that requires the entire model to be initialized."]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>r});var i=s(6540);const l={},t=i.createContext(l);function o(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);