"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9632],{319:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>o});var l=s(4848),i=s(8453);const t={},r="alloydb_client.py",a={id:"src/sunholo/database/alloydb_client",title:"alloydb_client.py",description:"Source: src/sunholo/database/alloydbclient.py",source:"@site/docs/src/sunholo/database/alloydb_client.md",sourceDirName:"src/sunholo/database",slug:"/src/sunholo/database/alloydb_client",permalink:"/docs/src/sunholo/database/alloydb_client",draft:!1,unlisted:!1,editUrl:"https://github.com/sunholo-data/sunholo-py/tree/main/docs/docs/src/sunholo/database/alloydb_client.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"alloydb.py",permalink:"/docs/src/sunholo/database/alloydb"},next:{title:"static_dbs.py",permalink:"/docs/src/sunholo/database/static_dbs"}},c={},o=[{value:"Classes",id:"classes",level:2},{value:"AlloyDBClient",id:"alloydbclient",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"alloydb_clientpy",children:"alloydb_client.py"})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.em,{children:"Source"}),": ",(0,l.jsx)(n.a,{href:"https://github.com/sunholo-data/sunholo-py/blob/main/src/sunholo/database/alloydb_client.py",children:"src/sunholo/database/alloydb_client.py"})]}),"\n",(0,l.jsx)(n.h2,{id:"classes",children:"Classes"}),"\n",(0,l.jsx)(n.h3,{id:"alloydbclient",children:"AlloyDBClient"}),"\n",(0,l.jsx)(n.p,{children:"A class to manage interactions with an AlloyDB instance."}),"\n",(0,l.jsx)(n.p,{children:"Example Usage:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'client = AlloyDBClient(\n    project_id="your-project-id",\n    region="your-region",\n    cluster_name="your-cluster-name",\n    instance_name="your-instance-name",\n    user="your-db-user",\n    password="your-db-password"\n)\n\n# Create a database\nclient.execute_sql("CREATE DATABASE my_database")\n\n# Execute other SQL statements\nclient.execute_sql("CREATE TABLE my_table (id INT, name VARCHAR(50))")\n'})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"init"}),"(self, config: sunholo.utils.config_class.ConfigManager = None, project_id: str = None, region: str = None, cluster_name: str = None, instance_name: str = None, user: str = None, password: str = None, db='postgres')","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Initializes the AlloyDB client."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"project_id (str): GCP project ID where the AlloyDB instance resides."}),"\n",(0,l.jsx)(n.li,{children:"region (str): The region where the AlloyDB instance is located."}),"\n",(0,l.jsx)(n.li,{children:"cluster_name (str): The name of the AlloyDB cluster."}),"\n",(0,l.jsx)(n.li,{children:"instance_name (str): The name of the AlloyDB instance."}),"\n",(0,l.jsx)(n.li,{children:"user (str): If user is None will use the default service email"}),"\n",(0,l.jsx)(n.li,{children:"db_name (str): The name of the database."}),"\n"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"_and_or_ilike(sources, search_type='OR', operator='ILIKE')"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"_build_instance_uri(self, project_id, region, cluster_name, instance_name)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"_create_engine(self)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"_create_engine_from_pg8000(self, user, password, db)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"_execute_sql_async_langchain(self, sql_statement)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"_execute_sql_async_pg8000(self, sql_statement, values=None)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Executes a given SQL statement asynchronously with error handling."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Args:\nsql_statement (str): The SQL statement to execute\nvalues (list, optional): Values for parameterized query"}),"\n",(0,l.jsx)(n.p,{children:"Returns:\nResult of SQL execution"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"_execute_sql_langchain(self, sql_statement)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"_execute_sql_pg8000(self, sql_statement, params=None)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Executes a given SQL statement with error handling."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Args:\nsql_statement (str): The SQL statement to execute.\nparams (dict or list, optional): Parameters for the SQL statement."}),"\n",(0,l.jsx)(n.p,{children:"Returns:\nThe result of the execution, if any."}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["_flatten_dict(self, nested_dict, parent_key='', separator='.')","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Flatten a nested dictionary into a single-level dictionary with dot notation for keys."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Args:\nnested_dict (dict): The nested dictionary to flatten\nparent_key (str): The parent key for the current recursion level\nseparator (str): The separator to use between key levels (default: '.')"}),"\n",(0,l.jsx)(n.p,{children:"Returns:\ndict: A flattened dictionary with special handling for lists"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["_flatten_dict_for_schema(self, nested_dict, parent_key='', separator='.')","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Flatten a nested dictionary for schema creation."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Args:\nnested_dict (dict): The nested dictionary to flatten\nparent_key (str): The parent key for the current recursion level\nseparator (str): The separator to use between key levels"}),"\n",(0,l.jsx)(n.p,{children:"Returns:\ndict: A flattened dictionary"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"_get_document_from_docstore(self, source: str, vector_name: str)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"_get_document_via_docid(self, source: str, vector_name: str, doc_id: str)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"_get_embedder(self)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"_get_sources_from_docstore(self, sources, vector_name, search_type='OR')"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Helper function to build the SQL query for fetching sources."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"_get_sql_type(self, value)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Helper method to determine SQL type from a Python value."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Args:\nvalue: The value to determine the column type"}),"\n",(0,l.jsx)(n.p,{children:"Returns:\nstr: SQL type"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["_get_sql_type_safe(self, value)","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Enhanced version of _get_sql_type with better type detection.\nHandles placeholder values and common patterns."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Args:\nvalue: The value to determine the column type"}),"\n",(0,l.jsx)(n.p,{children:"Returns:\nstr: SQL type"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["_insert_single_row(self, table_name: str, data: dict, metadata: dict = None, primary_key_column: str = 'id')","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Inserts a single row of data into the specified table."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Args:\ntable_name (str): Name of the table\ndata (dict): Data to write to the table\nmetadata (dict, optional): Additional metadata to include"}),"\n",(0,l.jsx)(n.p,{children:"Returns:\nResult of SQL execution"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"_list_sources_from_docstore(self, sources, vector_name, search_type='OR')"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Helper function to build the SQL query for listing sources."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"_similarity_search(self, query, source_filter: str = '', free_filter: str = None, vector_name: str = None)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"asimilarity_search(self, query: str, source_filter: str = '', free_filter: str = None, k: int = 5, vector_name: str = None)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"check_connection(self)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Checks if the database connection is still valid."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Returns:\nbool: True if connection is valid, False otherwise"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["check_row(self, table_name: str, primary_key_column: str, primary_key_value: str, columns: list = None, condition: str = None)","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Retrieves a row from the specified table based on the primary key."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Args:\ntable_name (str): Name of the table to query\nprimary_key_column (str): Name of the primary key column (e.g., 'id')\nprimary_key_value (str): Value of the primary key for the row to retrieve\ncolumns (list, optional): List of column names to retrieve. If None, retrieves all columns\ncondition (str, optional): Additional condition for the WHERE clause"}),"\n",(0,l.jsx)(n.p,{children:"Returns:\nThe row data if found, None otherwise"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"close(self)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Properly close the database connection."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"create_database(self, database_name)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"create_docstore_table(self, vector_name: str, users)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"create_index(self, vectorstore=None)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"create_schema(self, schema_name='public')"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"create_table_from_schema(self, table_name: str, schema_data: dict, users: list = None)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Creates or ensures a table exists based on the structure of the provided schema data,\nwith special handling for expandable lists."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Args:\ntable_name (str): Name of the table to create\nschema_data (dict): Data structure that matches the expected schema\nusers (list, optional): List of users to grant permissions to"}),"\n",(0,l.jsx)(n.p,{children:"Returns:\nResult of SQL execution"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["create_table_with_columns(self, table_name, column_definitions, if_not_exists=True, primary_key_column='id')","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Create a table with explicit column definitions."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Args:\ntable_name (str): The name of the table to create\ncolumn_definitions (list): List of column definition dictionaries:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"name: Column name"}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"type: PostgreSQL data type"}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"nullable: Whether column allows NULL (default True)"}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"default: Default value expression (optional)"}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"primary_key: Whether this is a primary key (default False)\nif_not_exists (bool): Whether to use IF NOT EXISTS clause\nprimary_key_column (str): default name of primary key if not specified in column_definitions"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Returns:\nResult of the execution"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"create_tables(self, vector_name, users)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"create_vectorstore_table(self, vector_name: str, users)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"delete_sources_from_alloydb(self, sources, vector_name)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Deletes from both vectorstore and docstore"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"ensure_connected(self)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Ensures the database connection is valid, attempting to reconnect if necessary."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Returns:\nbool: True if connection is valid or reconnection successful, False otherwise"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"execute_sql(self, sql_statement)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"execute_sql_async(self, sql_statement)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"fetch_owners(self)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"get_document_from_docstore(self, source: str, vector_name)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"get_document_from_docstore_async(self, source: str, vector_name: str)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"get_sources_from_docstore(self, sources, vector_name, search_type='OR', just_source_name=False)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Fetches sources from the docstore."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"get_sources_from_docstore_async(self, sources, vector_name, search_type='OR', just_source_name=False)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Fetches sources from the docstore asynchronously."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"get_table_columns(self, table_name, schema='public')"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Fetch column information for an existing table."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:'Args:\ntable_name (str): The table name to get columns for\nschema (str): Database schema, defaults to "public"'}),"\n",(0,l.jsx)(n.p,{children:"Returns:\nList[dict]: List of column information dictionaries with keys:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"name: column name"}),"\n",(0,l.jsx)(n.li,{children:"type: PostgreSQL data type"}),"\n",(0,l.jsx)(n.li,{children:"is_nullable: whether the column allows NULL values"}),"\n",(0,l.jsx)(n.li,{children:"default: default value if any"}),"\n"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"get_vectorstore(self, vector_name: str = None)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"grant_schema_permissions(self, schema_name, users)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"grant_table_permissions(self, table_name, users)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"insert_rows_safely(self, table_name, rows, metadata=None, continue_on_error=False, primary_key_column='id')"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Insert multiple rows into a table with error handling for individual rows."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Args:\ntable_name (str): The table to insert into\nrows (list): List of dictionaries containing row data\nmetadata (dict, optional): Additional metadata to include in each row\ncontinue_on_error (bool): Whether to continue if some rows fail\nprimary_key_column (str): The primary key in the table, default 'id'"}),"\n",(0,l.jsx)(n.p,{children:"Returns:\ndict: {\n'success': bool,\n'total_rows': int,\n'inserted_rows': int,\n'failed_rows': int,\n'errors': list of errors with row data\n}"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["map_data_to_columns(self, data, column_info, case_sensitive=False)","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Map data dictionary to available table columns, handling case sensitivity."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Args:\ndata (dict): Dictionary of data to map\ncolumn_info (list): List of column information dictionaries from get_table_columns\ncase_sensitive (bool): Whether to match column names case-sensitively"}),"\n",(0,l.jsx)(n.p,{children:"Returns:\ndict: Filtered data dictionary with only columns that exist in the table"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"refresh_index(self, vectorstore=None)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"safe_convert_value(self, value, target_type)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Safely convert a value to the target PostgreSQL type.\nHandles various formats and placeholder values."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Args:\nvalue: The value to convert\ntarget_type (str): PostgreSQL data type name"}),"\n",(0,l.jsx)(n.p,{children:"Returns:\nThe converted value appropriate for the target type, or None if conversion fails"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"similarity_search(self, query: str, source_filter: str = '', free_filter: str = None, k: int = 5, vector_name: str = None)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"No docstring available."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"update_row(self, table_name: str, primary_key_column: str, primary_key_value: str, update_data: dict, condition: str = None)"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Updates a row in the specified table based on the primary key."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Args:\ntable_name (str): Name of the table to update\nprimary_key_column (str): Name of the primary key column (e.g., 'acdid')\nprimary_key_value (str): Value of the primary key for the row to update\nupdate_data (dict): Dictionary containing column names and values to update\ncondition (str, optional): Additional condition for the WHERE clause"}),"\n",(0,l.jsx)(n.p,{children:"Returns:\nResult of SQL execution"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["write_data_to_table(self, table_name: str, data: dict, metadata: dict = None)","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Writes data to the specified table, with special handling for expandable lists."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Args:\ntable_name (str): Name of the table\ndata (dict): Data to write to the table\nmetadata (dict, optional): Additional metadata to include"}),"\n",(0,l.jsx)(n.p,{children:"Returns:\nList of results from SQL executions"})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var l=s(6540);const i={},t=l.createContext(i);function r(e){const n=l.useContext(t);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),l.createElement(t.Provider,{value:n},e.children)}}}]);